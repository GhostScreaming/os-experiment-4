LAB_04	实验报告

一、漏洞来源
    选择的漏洞是Dirty Cow（CVE-2016-5195）。这个bug自Linux 2.6.22(发布于 2007 年)存在至今，并于2016年10月18日被修复。在之后有大量针对不同Linux版本
的Dirty Cow POC文件发布，72小时内公开的可作非稳定漏洞利用的PoC已经有9个。下面列举几个POC的commit ID。
    1.866a2fdf425d084d7a9576e866db1a80c640f841
    2.5bb42823a76d13795bc430647295783d8c945179
    3.3638a9f899cfb2ad5b1ba722e55d69dc8f8fcd80
    
二、产生原因
    漏洞是由于Linux内核的内存子系统在处理 Copy-on-Write 时出现竞争条件（漏洞），导致私有的只读内存映射被破坏、获取读写权限后进一步提权漏洞。

三、修复办法
    2016年 10 月 18 日 Linux 内核小组发布官方补丁表示 CVE-2016-5195 （Dirty COW）漏洞已被修复。用户可到官网下载脚本进行检测。此外 Debian、
Ubuntu 版本  Linux 也已发布 CVE-2016-5195 漏洞公告。
    以CentOS 5/6/7 系列操作系统修复为例，操作步骤为：
    yum check-update |grep kernel
    yum update kernel
    lsinitrd /boot/initramfs-2.6.32-642.6.2.el6.x86_64.img |grep -i -E 'xen-blkfront|virtio_blk'
    重启后检验是否修复成功。

四、漏洞危害
    Red Hat 官网 21 日发布公告把漏洞评级为“重要”。
    黑客可以通过远程入侵获取低权限用户shell后，然后利用该漏洞在全版本Linux系统上实现本地提权，从而获取服务器root权限。此外，由于安卓系统是基于Linux
开发的，自1.0版本以来的所有Android版本都存在脏牛漏洞。这意味着目前几乎所有Android设备都存在脏牛漏洞，也就是说全都处于可以被利用的状态。

五、攻击步骤
    当调用write系统调用向/proc/self/mem文件中写入数据时，进入内核态后内核会调用get_user_pages函数获取要写入内存地址。get_user_pages会调用
follow_page_mask来获取这块内存的页表项，并同时要求页表项所指向的内存映射具有可写的权限。第一次获取内存的页表项会因为缺页而失败。get_user_page
调用faultin_page进行缺页处理后第二次调用follow_page_mask获取这块内存的页表项，如果需要获取的页表项指向的是一个只读的映射，那第二次获取也会失败。
这时候get_user_pages函数会第三次调用follow_page_mask来获取该内存的页表项，并且不再要求页表项所指向的内存映射具有可写的权限，这时是可以成功获取
的，获取成功后内核会对这个只读的内存进行强制的写入操作。这个实现是没有问题的，因为本来写入/proc/self/mem就是一个无视映射权限的强行写入，就算是文
件映射到虚拟内存中，也不会出现越权写：如果写入的虚拟内存是一个VM_PRIVATE的映射，那在缺页的时候内核就会执行COW操作产生一个副本来进行写入，写入的内
容是不会同步到文件中的如果写入的虚拟内存是一个VM_SHARE的映射，那mmap能够映射成功的充要条件就是进程拥有对该文件的写权限，这样写入的内容同步到文件中
也不算越权了。但是，在上述流程中，如果第二次获取页表项失败之后，另一个线程调用madvice(addr,addrlen, MADV_DONTNEED),其中addr~addr+addrlen是一个
只读文件的VM_PRIVATE的只读内存映射，那该映射的页表项会被置空。这时如果get_user_pages函数第三次调用follow_page_mask来获取该内存的页表项。由于这次
调用不再要求该内存映射具有写权限，所以在缺页处理的时候内核也不再会执行COW操作产生一个副本以供写入。所以缺页处理完成后后第四次调用follow_page_mask获
取这块内存的页表项的时候，不仅可以成功获取，而且获取之后强制的写入的内容也会同步到映射的只读文件中。从而导致了只读文件的越权写。
    dirty cow正是基于以上思路完成攻击。
